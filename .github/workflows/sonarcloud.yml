# SonarCloud analysis for C# repo that compiles with VS 2019 (hopefully works with VS 2022 also)
# -----------------------------------------------------------------------------
# What this does:
#   1) Builds the code under Sonar's Build Wrapper (produces compile_commands.json)
#   2) Runs the SonarCloud scanner
#   3) Waits for analysis to finish, pulls issues from SonarCloud's API,
#      converts to SARIF, uploads as an artifact
#   4) Publishes the SARIF to GitHub Code Scanning in a separate, least-privilege job
#
# Why it looks this way (key principles):
#   • Default‑deny permissions – read‑only by default; elevate only in the upload job
#   • Pinned actions – commit SHAs, not floating tags, for reproducibility and tamper‑resistance
#   • Hardened egress – audit (or block) network calls to limit exfiltration risk
#   • Concurrency – cancel superseded runs to save time and money
#   • Timeouts – fail fast instead of hanging for hours
#   • Scoped checkout credentials – don't persist the GitHub token into the repo
#   • Clear triggers – run only when relevant files change
#
# Prereqs in the repo:
#   • sonar-project.properties with:
#       sonar.projectKey=<your_sonarcloud_project_key>
#       sonar.organization=<your_sonarcloud_org_key>
#       sonar.sources=.
#   • More requirements described below
#
# Secret needed:
#   • SONAR_TOKEN (Actions → Secrets) – a SonarCloud user token with access to the project

# SonarCloud analysis for a .NET/MSBuild repo (Windows/VS2022)
# -----------------------------------------------------------------------------
# Key principles kept from your C workflow:
#   • Default-deny perms; elevate only in the upload job
#   • Pinned actions by commit SHA
#   • Hardened egress (audit mode by default)
#   • Concurrency + timeouts
#   • No persisted checkout creds
#   • Clear PR triggers
#
# Notes:
#   • Uses GitHub-hosted Windows 2022 runner (includes Visual Studio 2022).
#   • Uses SonarScanner for .NET (begin → msbuild → end).
#   • Still generates SARIF from SonarCloud issues and publishes to Code Scanning.

name: SonarCloud (.NET / MSBuild on Windows)

on:
  push:
    branches: [ "main" ]
    # Trigger only when .NET/MSBuild sources, the workflow, or Sonar properties change
    # paths:
    #   - 'Landform.sln'
    #   - '**/*.csproj'
    #   - '**/*.vbproj'
    #   - '**/*.props'
    #   - '**/*.targets'
    #   - '.github/workflows/sonarcloud-dotnet.yml'
  pull_request:
    branches: [ "main" ]
    types: [opened, synchronize, reopened]
    # paths:
    #   - 'Landform.sln'
    #   - '**/*.csproj'
    #   - '**/*.vbproj'
    #   - '**/*.props'
    #   - '**/*.targets'
    #   - '.github/workflows/sonarcloud-dotnet.yml'
  # workflow_dispatch:

# Cancel older in-flight runs of the same ref. Avoids CI pile-ups on active PRs.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

# Default-deny: grant only read by default at the workflow level.
permissions:
  contents: read

jobs:
  # Job 1: build + scan + export SARIF (no write scopes here)
  build-and-scan:
    name: Build and analyze (Windows/VS2022)
    runs-on: windows-2022                # GitHub-hosted Windows Server 2022 + VS 2022
    timeout-minutes: 25                  # Cap wall-clock time for the job
    permissions:
      contents: read                     # Read-only; no secret write scopes here
    env:
      # We will build this specific solution at the repo root.
      SOLUTION_FILE: 'Landform.sln'

    steps:
      # Lock down outbound network. Start in audit mode; switch to block + allowlist later.
      - name: Harden runner (audit egress)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit
          # When the workflow is stable, prefer:
          # egress-policy: block
          # allowed-endpoints: >
          #   sonarcloud.io
          #   api.sonarcloud.io
          #   github.com
          #   api.github.com
          #   uploads.github.com
          #   objects.githubusercontent.com
          #   dist.nuget.org
          #   api.nuget.org
          #   globalcdn.nuget.org

      # Do not persist the GITHUB_TOKEN into the repo (reduces risk in later steps)
      - name: Checkout (no persisted creds)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0                 # Full history improves blame/issue precision
          persist-credentials: false     # Do not leave a token in .git/config

      # MSBuild scanner rule: it will FAIL if any sonar-project.properties exists in the repo.
      # We read the needed keys from the file(s) once, export them into the job environment,
      # then remove ALL sonar-project.properties files before running 'begin'.
      - name: Extract Sonar keys and remove sonar-project.properties (required for MSBuild scanner)
        shell: pwsh
        run: |
          $files = Get-ChildItem -Path . -Recurse -Filter 'sonar-project.properties' -File
          if ($files) {
            # Read first file for keys (usually root); later files typically repeat the same values.
            $text = Get-Content -Path $files[0].FullName -Raw
            $proj = ($text | Select-String -Pattern '^sonar\.projectKey=(.+)$').Matches.Groups[1].Value
            $org  = ($text | Select-String -Pattern '^sonar\.organization=(.+)$').Matches.Groups[1].Value
            if ($proj) { Add-Content $env:GITHUB_ENV "SONAR_PROJECT_KEY=$proj" }
            if ($org)  { Add-Content $env:GITHUB_ENV "SONAR_ORG=$org" }
            # Remove every sonar-project.properties to satisfy the MSBuild scanner
            $files | ForEach-Object { Remove-Item $_.FullName -Force }
          }
          # Optional: allow secrets to override (useful if you remove the file from the repo later)
          if ($env:SONAR_PROJECT_KEY -eq $null -or $env:SONAR_PROJECT_KEY -eq '') {
            if ($env:SONAR_PROJECT_KEY_SECRET) { Add-Content $env:GITHUB_ENV "SONAR_PROJECT_KEY=$env:SONAR_PROJECT_KEY_SECRET" }
          }
          if ($env:SONAR_ORG -eq $null -or $env:SONAR_ORG -eq '') {
            if ($env:SONAR_ORG_SECRET) { Add-Content $env:GITHUB_ENV "SONAR_ORG=$env:SONAR_ORG_SECRET" }
          }

      # Cache the packages/ folder used by packages.config projects to speed up subsequent builds
      # NOTE: We use a tag here for reliability; if you require pin-by-SHA, replace @v4 with a specific commit SHA.
      - name: Cache NuGet packages folder (packages.config)
        uses: actions/cache@v4
        with:
          path: packages
          key: packages-${{ runner.os }}-${{ hashFiles('**/packages.config') }}
          restore-keys: |
            packages-${{ runner.os }}-

      # Restore NuGet packages for packages.config projects (creates ./packages)
      - name: NuGet restore (packages.config)
        shell: pwsh
        run: |
          $nuget = "$env:RUNNER_TEMP\nuget.exe"
          Invoke-WebRequest -Uri https://dist.nuget.org/win-x86-commandline/latest/nuget.exe -OutFile $nuget
          & $nuget restore "$env:SOLUTION_FILE" -NonInteractive -Verbosity normal

      # Put MSBuild (VS 2022) on PATH and prefer 64-bit
      - name: Setup MSBuild (x64)
        uses: microsoft/setup-msbuild@6fb02220983dee41ce7ae257b6f4d8f9bf5ed4ce # v2.0.0
        with:
          msbuild-architecture: x64

      # Begin SonarScanner for .NET
      - name: SonarScanner begin
        shell: pwsh
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}   # SonarCloud user token; no GitHub write scope needed
        run: |
          if (-not $env:SONAR_PROJECT_KEY) { throw "SONAR_PROJECT_KEY not set; ensure it was read from sonar-project.properties or provided via secrets." }
          if (-not $env:SONAR_ORG)         { throw "SONAR_ORG not set; ensure it was read from sonar-project.properties or provided via secrets." }
          dotnet tool install --global dotnet-sonarscanner --version 9.*
          $env:PATH += ";$env:USERPROFILE\.dotnet\tools"
          dotnet-sonarscanner begin `
            /k:"$env:SONAR_PROJECT_KEY" `
            /o:"$env:SONAR_ORG" `
            /d:sonar.host.url="https://sonarcloud.io" `
            /d:sonar.verbose=true

      # Build Landform.sln with MSBuild
      - name: Build solution (MSBuild)
        shell: pwsh
        run: |
          $sln = Resolve-Path "$env:SOLUTION_FILE"
          Write-Host "Building $sln"
          msbuild "$sln" /t:Rebuild /p:Configuration=Release /m

      # End SonarScanner for .NET (submits analysis)
      - name: SonarScanner end
        shell: pwsh
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          $env:PATH += ";$env:USERPROFILE\.dotnet\tools"
          dotnet-sonarscanner end

      # Convert SonarCloud issues → SARIF so GitHub Code Scanning can ingest them.
      # Why a custom step? SonarCloud doesn’t publish SARIF directly, so we fetch issues via API and transcode.
      # Use a Bash heredoc. IMPORTANT: keep the indentation of the heredoc body and terminator
      # exactly the same as the 'cat' line so YAML keeps them in the run block.
      - name: Generate SARIF from SonarCloud issues
        shell: bash
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p reports
          cat > reports/generate_sarif.py <<'EOF'
          import base64, json, os, time, urllib.parse, urllib.request, pathlib, sys

          def read_prop(k):
              with open("sonar-project.properties","r",encoding="utf-8") as f:
                  for line in f:
                      line=line.strip()
                      if line.startswith(k+"="):
                          return line.split("=",1)[1].strip()
              raise RuntimeError(f"{k} not found in sonar-project.properties")

          def get_json(url, token):
              req = urllib.request.Request(url)
              auth = base64.b64encode((token + ":").encode()).decode()
              req.add_header("Authorization", "Basic " + auth)
              with urllib.request.urlopen(req, timeout=30) as r:
                  return json.load(r)

          base = "https://sonarcloud.io"
          token = os.environ["SONAR_TOKEN"]
          project_key = os.environ.get("SONAR_PROJECT_KEY") or "UNKNOWN"
          print(f"Project: {project_key}")

          # Wait for most recent CE task to finish
          for _ in range(120):  # ~6 minutes max
              act = get_json(f"{base}/api/ce/activity?component={urllib.parse.quote(project_key)}&onlyCurrents=true&ps=1", token)
              tasks = act.get("tasks", [])
              if tasks:
                  tid = tasks[0]["id"]
                  ce = get_json(f"{base}/api/ce/task?id={tid}", token)
                  status = ce["task"]["status"]
                  print("CE status:", status)
                  if status in ("SUCCESS", "FAILED", "CANCELED"):
                      break
              else:
                  print("No CE tasks yet")
              time.sleep(3)

          # Pull unresolved issues
          p=1; page_size=500; issues=[]
          while True:
              data = get_json(f"{base}/api/issues/search?componentKeys={urllib.parse.quote(project_key)}&resolved=false&ps={page_size}&p={p}", token)
              batch = data.get("issues", [])
              if not batch:
                  break
              issues.extend(batch)
              total = data.get("total", 0)
              if p*page_size >= total:
                  break
              p += 1

          def level(sev):
              return {"BLOCKER":"error","CRITICAL":"error","MAJOR":"warning","MINOR":"note","INFO":"note"}.get(sev,"warning")

          runs=[{"tool":{"driver":{"name":"SonarCloud","informationUri":"https://sonarcloud.io","rules":[]}},"results":[]}]

          rule_added=set()
          for it in issues:
              rid=str(it.get("rule","unknown"))
              if rid not in rule_added:
                  runs[0]["tool"]["driver"]["rules"].append({
                      "id": rid,
                      "shortDescription": {"text": (it.get("message","") or "")[:120]}
                  })
                  rule_added.add(rid)
              comp = it.get("component","")
              path = comp.split(":",1)[1] if ":" in comp else comp
              tr = it.get("textRange") or {}
              sl = tr.get("startLine", 1)
              sc = (tr.get("startOffset",0) or 0) + 1
              el = tr.get("endLine", sl)
              ec = max(tr.get("endOffset", sc), sc)
              runs[0]["results"].append({
                  "ruleId": rid,
                  "level": level(it.get("severity","MAJOR")),
                  "message": {"text": it.get("message","")},
                  "locations": [{
                      "physicalLocation": {
                          "artifactLocation": {"uri": path, "uriBaseId": "PROJECT_ROOT"},
                          "region": {"startLine": sl, "startColumn": sc, "endLine": el, "endColumn": ec}
                      }
                  }],
                  "fingerprints": {"sonarIssueKey": it.get("key","")}
              })

          pathlib.Path("reports").mkdir(parents=True, exist_ok=True)
          sarif={"version":"2.1.0","$schema":"https://json.schemastore.org/sarif-2.1.0.json","runs":runs}
          with open("reports/sonarcloud.sarif","w",encoding="utf-8") as f:
              json.dump(sarif, f, ensure_ascii=False)
          print(f"Wrote {len(issues)} issues to reports/sonarcloud.sarif")
          EOF
          # Make SONAR_PROJECT_KEY available to the Python step for nicer logging
          echo "SONAR_PROJECT_KEY=${SONAR_PROJECT_KEY}" >> $GITHUB_ENV
          python reports/generate_sarif.py

      # Keep an auditable copy of the SARIF. Do not upload secrets.
      - name: Upload SARIF as artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: sonarcloud-sarif
          path: reports/sonarcloud.sarif
          retention-days: 7
          if-no-files-found: error

  # Job 2: upload SARIF to GitHub Code Scanning with the only write scope it needs
  upload-to-code-scanning:
    name: Publish SARIF to Code Scanning
    needs: build-and-scan               # Run only after SARIF is produced
    runs-on: windows-2022
    timeout-minutes: 5
    permissions:
      contents: read
      security-events: write            # Narrow write scope to this tiny, isolated job
      actions: read
    steps:
      - name: Harden runner (audit egress)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Download SARIF artifact
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: sonarcloud-sarif
          path: reports

      - name: Upload SARIF to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@3c3833e0f8c1c83d449a7478aa59c036a9165498 # v3.29.11
        with:
          sarif_file: reports/sonarcloud.sarif
          category: sonarcloud
